import type {Adapter, Builder} from '@sveltejs/kit'
import {bundleEdgeFunction, HLogger} from '@hrishikeshk/utils'
import type {Config as EdgeFunctionsConfig} from '@netlify/edge-functions'
import type {Config as FunctionsConfig} from '@netlify/functions'
import {cwd} from 'node:process'
import {join, relative} from 'node:path'
import {writeFileSync} from 'node:fs'

const fnName = 'SvelteKit Server'
const generator = '@hrishikeshk/sveltekit-adapter-netlify@0.0.1'
const logger = new HLogger(generator)
const workingDir = cwd()
const ntlFrameworksApiDir = join(workingDir, '.netlify/v1')
const ntlEdgeFunctionsDir = join(ntlFrameworksApiDir, 'edge-functions')
const ntlFunctionsDir = join(ntlFrameworksApiDir, 'functions')
const skServerDir = join(workingDir, '.svelte-kit/netlify')
const skEdgeFunctionPath = join(ntlEdgeFunctionsDir, 'sk-server.js')
const skFunctionPath = join(ntlFunctionsDir, 'sk-server.js')

async function init(builder: Builder) {
  const publishDir = join(workingDir, 'build')
  logger.info(`publish dir is ${publishDir}`)
  const skPublishDir = join(publishDir, builder.config.kit.paths.base)

  /*
    delete the folders this adapter writes to
    publish_dir will contain all static files
    sk_edge_function_path will be the path to the Edge Function
    sk_function_path will be the path to the Lambda Function
    sk_server_dir will contain the server files generated by SvelteKit's builder.writeServer()
   */
  const deleteDirs = [
    publishDir,
    skEdgeFunctionPath,
    skFunctionPath,
    skServerDir
  ]

  try {
    logger.warn(`deleting: ${deleteDirs.map((d) => `\n  - ${d}`).join()}`)
    for (const d of deleteDirs) {
      builder.rimraf(d)
    }
    logger.success('successfully deleted')
  } catch (e) {
    logger.error('failed to delete')
    throw e
  }

  /*
    create directories before writing data to prevent any failure
    we create the most-nested directory so parent dirs are automatically created
    ntl_frameworks_api_dir is required to write the config,
    (Edge) Functions will create their directory when needed
    sk_publish_dir will auto-create publish_dir
   */
  builder.mkdirp(ntlFrameworksApiDir)
  builder.mkdirp(skPublishDir)

  /* write common files, adapter-specific files will be written later */
  try {
    logger.info(`writing client assets to ${skPublishDir}`)
    logger.info(`writing prerendered files to ${skPublishDir}`)
    logger.info(`writing server assets to ${skServerDir}`)
    logger.info(`writing Netlify config to ${ntlFrameworksApiDir}`)
    builder.writeClient(skPublishDir)
    builder.writePrerendered(skPublishDir)
    builder.writeServer(skServerDir)
    writeFileSync(
      join(ntlFrameworksApiDir, 'config.json'),
      JSON.stringify({
        headers: [
          {
            for: `/${builder.getAppPath()}/immutable/*`,
            values: {
              'cache-control': 'immutable, public, max-age=31536000'
            }
          }
        ]
      })
    )
    logger.success('successfully wrote static and config files')
  } catch (e) {
    logger.error('failed to write files')
    throw e
  }
}

export function adapterNetlifyEdgeFunctions(
  options: Partial<
    Pick<EdgeFunctionsConfig, 'excludedPath' | 'onError' | 'rateLimit'>
  > = {}
) {
  return {
    async adapt(builder) {
      logger.info('adapter is using Netlify Edge Functions')
      await init(builder)

      function pathToRegex(path: string, suffix?: string) {
        return [
          '^',
          path
            .split('')
            .map((s) => {
              if (/[A-Za-z]/.test(s)) {
                return `[${s.toUpperCase()}${s.toLowerCase()}]`
              }
              switch (s) {
                case '/':
                  return '\\/'
                case '.':
                  return '\\.'
                case '*':
                  return '.*'
                default:
                  return s
              }
            })
            .join(''),
          suffix,
          '$'
        ].join('')
      }

      const efn = `import {Server} from '${join(builder.getServerDirectory(), 'index.js')}'
const server = new Server(${builder.generateManifest({
        relativePath: './'
      })})
await server.init({
  env: Deno.env.toObject()
})
export default async function(req, context) {
  return server.respond(req, {
    getClientAddress() {
      return context.ip
    },
    platform: {
      context
    }
  })
}
export const config = {
  excludedPattern: ${JSON.stringify(
    [
      `${pathToRegex('/.netlify/*')}`,
      `${pathToRegex('/favicon.ico')}`,
      `${pathToRegex(`/${builder.getAppPath()}/immutable/*`)}`
    ]
      .concat(
        builder.routes
          .filter((r) => r.prerender)
          .flatMap((r) => {
            if (r.id === '/') {
              /* https://regex101.com/r/5Pk7mO/1 */
              return pathToRegex(
                '/',
                '(([Hh][Oo][Mm][Ee]|[Ii][Nn][Dd][Ee][Xx])\\.[Hh][Tt][Mm][Ll]?)?'
              )
            }
            /* https://regex101.com/r/eE3kiI/1 */
            return pathToRegex(
              r.id,
              '(\\.[Hh][Tt][Mm][Ll]?|\\/|(\\/([Ii][Nn][Dd][Ee][Xx]|[Hh][Oo][Mm][Ee]))\\.[Hh][Tt][Mm][Ll]?)?'
            )
          })
      )
      .concat(options.excludedPath || [])
  )},
  generator: '${generator}',
  name: '${fnName}',
  onError: ${JSON.stringify(options.onError || undefined)},
  pattern: ${JSON.stringify(pathToRegex('/*'))},
  rateLimit: ${JSON.stringify(options.rateLimit || undefined)}
}`

      /*
        write the Edge Function into SvelteKit's server dir,
        that will be processed by esbuild and written to Netlify's output dir
       */
      const ntlEfPath = join(skServerDir, 'sk-server.js')

      try {
        logger.info(`writing Edge Function to ${skServerDir}`)
        builder.mkdirp(ntlEdgeFunctionsDir)
        writeFileSync(ntlEfPath, efn)
        logger.success('successfully wrote Edge Function')
      } catch (e) {
        logger.error('failed to write Edge Function')
        throw e
      }

      try {
        logger.info('Bundling Edge Function using esbuild')
        await bundleEdgeFunction(ntlEfPath, skEdgeFunctionPath)
        logger.success('successfully bundled Edge Function')
      } catch (e) {
        logger.error('failed to bundle Edge Function')
        throw e
      }
    },
    name: generator,
    supports: {
      read(config) {
        throw new Error(
          `${generator} cannot use \`read\` from \`$apps/server\' in route \`${config.route.id}\`, switch to \`adapterNetlifyFunctions\``
        )
      }
    }
  } satisfies Adapter
}

export function adapterNetlifyFunctions(
  options: Partial<Pick<FunctionsConfig, 'excludedPath' | 'rateLimit'>> = {}
) {
  return {
    async adapt(builder) {
      logger.info('adapter is using Netlify Functions')
      await init(builder)

      const fn = `import {env} from 'node:process'
import {Server} from '${join(builder.getServerDirectory(), 'index.js')}'
import {webcrypto} from 'node:crypto'
if (!globalThis.crypto) {
  Object.defineProperty(globalThis, 'crypto', {
    configurable: true,
    enumerable: true,
    value: webcrypto,
    writable: true
  })
}
const server = new Server(${builder.generateManifest({
        relativePath: relative(ntlFunctionsDir, skServerDir)
      })})
await server.init({
  env
})
export default async function(req, context) {
  return server.respond(req, {
    getClientAddress() {
      return context.ip
    },
    platform: {
      context
    }
  })
}
export const config = {
  displayName: '${fnName}',
  excludedPath: ${JSON.stringify(
    ['/.netlify/*'].concat(options.excludedPath || [])
  )},
  generator: '${generator}',
  path: '/*',
  preferStatic: true,
  rateLimit: ${JSON.stringify(options.rateLimit || undefined)}
}`

      try {
        logger.info(`writing Function to ${ntlFunctionsDir}`)
        builder.mkdirp(ntlFunctionsDir)
        writeFileSync(skFunctionPath, fn)
        logger.success('successfully wrote Function')
      } catch (e) {
        logger.error('failed to write Function')
        throw e
      }
    },
    name: generator
  } satisfies Adapter
}

export function adapterNetlifyStatic() {
  return {
    async adapt(builder) {
      const dynamicRoutes = builder.routes.filter((r) => !r.prerender)
      if (dynamicRoutes.length) {
        logger.error(
          `${generator} found the following dynamic routes:${dynamicRoutes.map((r) => `\n  - ${join(relative(workingDir, builder.config.kit.files.routes), r.id)}`)}`
        )
        throw new Error('')
      }
      builder.generateEnvModule()
      await init(builder)
    },
    name: generator
  } satisfies Adapter
}
